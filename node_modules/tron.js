var net = require("net");

class Cell {
	constructor(x, y, val, board) {
		this.coords = [x, y];
		this.val = val;
		this.board = board;
	}
	
	up() {
		return this.board.get(this.coords[0], this.coords[1] - 1);
	}
	
	down() {
		return this.board.get(this.coords[0], this.coords[1] + 1);
	}
	
	left() {
		return this.board.get(this.coords[0] - 1, this.coords[1]);
	}
	
	right() {
		return this.board.get(this.coords[0] + 1, this.coords[1]);
	}
	
	toString() {
		var str;
		if (this.val == 0)
			str = " ";
		else if (this.val == 1)
			str = "#";
		else
			str = "@";
		return str;
	}
}

class Board {
	constructor(x, y) {
		if (y == undefined) {
			if (! Array.isArray(x) || x.length != 2)
				throw "Unable to create board";
			y = x[1];
			x = x[0];
		}
		this.grid = new Array(x);
		for (var i = 0; i < this.grid.length; i++) {
			this.grid[i] = new Array(y);
			for (var j = 0; j < this.grid[i].length; j++) {
				this.grid[i][j] = new Cell(i, j, 0, this);
			}
		}
		this.size = [x, y];
	}
	
	get(x, y) {
		if (y == undefined) {
			if (! Array.isArray(x) || x.length != 2)
				return null;
			y = x[1];
			x = x[0];
		}
		return (x >= 0 && x < this.grid.length && y >= 0 && y < this.grid[x].length) ? this.grid[x][y] : null;
	}
	
	set(x, y, val) {
		if (val == undefined) {
			if (! Array.isArray(x) || x.length != 2)
				return false;
			val = y;
			y = x[1];
			x = x[0];
		}
		if (x >= 0 && x < this.grid.length && y >= 0 && y < this.grid[x].length) {
			this.grid[x][y].val = val;
			return true;
		}
		else
			return false;
	}
	
	toString() {
		var str = "+";
		for (var i = 0; i < this.size[0]; i++)
			str += "-";
		str += "+\n";
		this.grid.forEach(row => {
			str += "|";
			row.forEach(cell => {
				str += cell.toString();
			});
			str += "|\n";
		});
		str += "+";
		for (var i = 0; i < this.size[0]; i++)
			str += "-";
		str += "+";
		return str;
	}
}

class Player {
	constructor(name, moves, board) {
		this.name = name;
		this.moves = moves == undefined ? ["LEFT", "UP", "RIGHT", "DOWN"] : moves;
		this.connection = null;
		this.id = null;
		this.board = board == undefined ? null : board;
		this.players = new Array(4);
	}
	
	connect(port, host) {
		if (host == undefined) {
			if (typeof port != "object")
				host = "localhost";
			else {
				if (port.port == undefined)
					return false;
				if (port.host == undefined)
					host = "localhost";
				else
					host = port.host;
				port = port.port;
			}
		}
		this.connection = net.createConnection({host: host, port: port}, () => {
			this.connection.write(this.name);
		});
		
		this.connection.on("data", (data) => {
			this.read(data);
		});
		
		this.connection.on("error", (err) => {
			console.error("Error occurred in connection");
		});
		
		this.connection.on("close", () => {
			console.log("Connection closed");
		});
	}
	
	read(data) {
		var msg = data.toString();
		console.info("Data received: " + msg);
		
		if (this.id == null) {
			this.id = Number(msg);
		}
		else if (this.board == null) {
			var boardSize, selfPos;
			msg = msg.split(";");
			boardSize = arrayToInt(msg[0].split(":"));
			this.board = new Board(boardSize);
			selfPos = arrayToInt(msg[1].split(":"));
			
			var startPos = [
				[Math.trunc(boardSize[0] / 2), 0],
				[0, Math.trunc(boardSize[1] / 2)],
				[Math.trunc(boardSize[0] / 2), boardSize[1] - 1],
				[boardSize[0] - 1, Math.trunc(boardSize[1] / 2)]
			];
			
			for (var i = 0; i < 4; i++) {
				if (i == this.id) {
					this.players[i] = this;
					this.board.set(selfPos, this);
				}
				else {
					this.players[i] = new Player("Enemy starting at " + startPos[i][0] + ", " + startPos[i][1], undefined, this.board);
					this.board.set(startPos[i], this.players[i]);
				}
			}
			
			this.connection.write("DOWN");
		}
		else {
			var positions = msg.split(";").map(pos => arrayToInt(pos.split(":")));
			for (var i = 0; i < 4; i++)
				this.players[i].updatePos(positions[i]);
			
			console.log(this.board.toString());
			
			this.connection.write("DOWN");
		}
	}
	
	getAvailableMoves() {
		return this.moves.filter(move => this.testMove(move));
	}
	
	testMove(move) {
		var nextPos = this.nextPos(move);
		
		return nextPos[0] >= 0 && nextPos[0] < this.board.size[0] && nextPos[1] >= 0 && nextPos[1] < this.board.size[1] && this.board.get(nextPos) == 0;
	}
	
	nextPos(move) {
		var nextPos = this.pos.slice();
		
		switch (move) {
		case "UP":
			nextPos[1] -= 1;
			break;
		case "DOWN":
			nextPos[1] += 1;
			break;
		case "LEFT":
			nextPos[0] -= 1;
			break;
		case "RIGHT":
			nextPos[0] += 1;
			break;
		}
		return nextPos;
	}
	
	move(move) {
		if (this.testMove(move)) {
			this.forceMove(move);
			return true;
		}
		else {
			return false;
		}
	}
	
	forceMove(move) {
		if (this.moves.includes(move)) {
			this.connection.write(move);
			return true;
		}
		else {
			return false;
		}
	}
	
	updatePos(x, y) {
		if (y == undefined) {
			if (! Array.isArray(x) || x.length != 2)
				throw "Unable to read new position";
			y = x[1];
			x = x[0];
		}
		this.board.set(this.pos, 1);
		this.board.set(x, y, this);
		this.pos = [x, y];
	}
}

function arrayToInt(array) {
	for (var i = 0; i < array.length; i++)
		array[i] = Number(array[i]);
	return array;
}

exports.Player = Player;
exports.Board = Board;
exports.Cell = Cell;